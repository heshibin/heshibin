

# 常见主键id生产策略讲解

**单库下一般使用Mysql自增ID, 但是分库分表后，会造成不同分片上的数据表主键会重复。**

 <br></br>

- 性能强劲
- 全局唯一
- 防止恶意用户规矩id的规则来获取数据

 <br></br>

 <br></br>

### 业界常用ID解决方案

 <br></br>

#### 数据库自增ID

 <br></br>

- 利用自增id, 设置不同的自增步长，auto_increment_offset、auto-increment-increment
- **缺点**
  - 依靠数据库系统的功能实现，但是未来扩容麻烦
  - 主从切换时的不一致可能会导致重复发号
  - 性能瓶颈存在单台sql上

 <br></br>

#### UUID

 <br></br>

- 性能非常高，没有网络消耗
- **缺点**
  - 无序的字符串，不具备趋势自增特性
  - UUID太长，不易于存储，浪费存储空间，很多场景不适用

 <br></br>

#### Redis发号器

 <br></br>

- 利用Redis的INCR和INCRBY来实现，原子操作，线程安全，性能比Mysql强劲
- **缺点**
  - 需要占用网络资源，增加系统复杂度

 <br></br>

#### Snowflake雪花算法

 <br></br>

- twitter 开源的分布式 ID 生成算法，代码实现简单、不占用宽带、数据迁移不受影响
- 生成的 id 中包含有时间戳，所以生成的 id 按照时间递增
- 部署了多台服务器，需要保证系统时间一样，机器编号不一样
- **缺点**
  - 依赖系统时钟（多台服务器时间一定要一样）